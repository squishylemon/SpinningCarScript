// _______ ______   ______    _______ _______ _______  ______ _______ _______ ______   ______ 
//(_______|____  \ / _____)  (_______|_______|_______)/ _____|_______|_______|_____ \ / _____)
//     _   ____)  | (____     _       _     _ _______( (____     _    _____   _____) | (____  
// _  | | |  __  ( \____ \   | |     | |   | |  ___  |\____ \   | |  |  ___) |  __  / \____ \ 
//| |_| | | |__)  )_____) )  | |_____| |___| | |   | |_____) )  | |  | |_____| |  \ \ _____) )
// \___/  |______/(______/    \______)\_____/|_|   |_(______/   |_|  |_______)_|   |_(______/ 
//
// PLAN ₿                                                                                     
//
// BTC: 19oUeJ9rkrJ1siGvnd4wahQVMGjDiFoAiN
//
// https://www.lookintobitcoin.com/

import com.nolimitscoaster.*; import nlvm.math3d.*; public class sensor_track_attach extends Script { static final String title = "JBS Coasters - Sensor: "; private SceneObject sco; private SceneObjectElement[] lsm_sco_elements = new SceneObjectElement[100]; private SceneObjectElement emission; private SceneObjectLight light; String coaster_name; int car_num = 1; public Coaster coaster; Train train; float range = 1000.0f; Matrix4x4f offset_matrix = new Matrix4x4f(); Matrix4x4f matrix = new Matrix4x4f(); private Vector3f rotation = new Vector3f(); private Vector3f position = new Vector3f(); private Vector4f light_Colour = new Vector4f(0.5f,0.0f,0.0f,1.0f); private Vector4f light_Current_Colour = new Vector4f(); private Vector4f UndetectedDefaultColour = new Vector4f(0.0f,0.5f,0.0f,1.0f); TrackPos track_pos; int lsm_elements=1; bool attached = true; bool transferTable = false; bool dropTrack = false; bool transferTableExit = false; private bool enabled=true; private float transTime=2.0f; private float flickerAmount=0.05f; private float flickerTrans=0.6f; private float active_distance=20.0f; private bool changed; private float total_Time=0; private float previous_Time=0; private Vector3f pos = new Vector3f(); public bool onInit() { sco=sim.getSceneObjectForEntityId(getParentEntityId()); if(sco==null){System.err.println(title+"sco not found.");return false;} emission=sco.getElementForName(("LIGHT").toString()); track_pos = sim.findNearestCoasterTrack(sco.getTranslation(), 20.0f); if(track_pos==null){System.err.println(title+"No Track Found.");return false;} sco.setMatrix(track_pos.getCenterRailsMatrix()); sco.getTranslation(pos); coaster = sco.getCoasterParameter("coaster_name"); if(coaster==null){System.err.println(title+"Please enter coaster name into friction wheels properties.");return false;} light = sco.getLightForName("Sensor Light"); if(light==null){System.err.println(title+"Light not found.");return false;} return true; } private void setTransform(SceneObject sco, Vector3f pos, Vector3f rot) { sco.setTranslation(pos.x,pos.y,pos.z); sco.setRotation(rot.x,rot.y,rot.z); } private void found(){ light_Colour=new Vector4f(1.0f,0.0f,0.0f,1.0f); emission.setEntityColor(1,light_Colour); set_Colour(light_Colour.x,light_Colour.y,light_Colour.z); } private void lost(){ light_Colour=new Vector4f(0.0f,1.0f,0.0f,1.0f); emission.setEntityColor(1,light_Colour); set_Colour(light_Colour.x,light_Colour.y,light_Colour.z); } private void active(){ if (sim.isViewerInsideSphere(pos, active_distance) == true){ if (changed==false){total_Time=0;previous_Time=0;} changed=true; if (total_Time<=transTime&&enabled==true){enable_Transition();}else{if(enabled==true){light.setEnabled(true);}else{light.setEnabled(false);}} if (total_Time<=flickerTrans&&enabled==true){flicker_Transition();}else{if(enabled==true){light.setEnabled(true);}else{light.setEnabled(false);}} } else{if (changed==true){total_Time=0;previous_Time=0;} changed=false; if(enabled==true){disable_Transition();}else{light.setEnabled(false);} } } private void set_Colour(float X,float Y,float Z){ light.setColor(X,Y,Z); } private void enable_Transition(){ light_Current_Colour.x = light_Colour.x * (total_Time/transTime); light_Current_Colour.y = light_Colour.y * (total_Time/transTime); light_Current_Colour.z = light_Colour.z * (total_Time/transTime); set_Colour(light_Current_Colour.x,light_Current_Colour.y,light_Current_Colour.z); } private void disable_Transition(){ light_Current_Colour.x = light_Colour.x * (1-(total_Time/transTime)); light_Current_Colour.y = light_Colour.y * (1-(total_Time/transTime)); light_Current_Colour.z = light_Colour.z * (1-(total_Time/transTime)); set_Colour(light_Current_Colour.x,light_Current_Colour.y,light_Current_Colour.z); } private void flicker_Transition(){ if (total_Time>=((flickerAmount*(total_Time/flickerTrans)))+previous_Time){ previous_Time=total_Time; if(light.isEnabled()==true){light.setEnabled(false);}else{light.setEnabled(true);} } } bool applied=false; public void onNextFrame(float tick) { total_Time+=tick; active(); train = coaster.findNearestTrain(sco.getTranslation(), 1.1f); if (train==null&&applied==false){ lost(); applied=true; }else if(train!=null&&applied==true){ found(); applied=false; } } } 

// _______ ______   ______    _______ _______ _______  ______ _______ _______ ______   ______ 
//(_______|____  \ / _____)  (_______|_______|_______)/ _____|_______|_______|_____ \ / _____)
//     _   ____)  | (____     _       _     _ _______( (____     _    _____   _____) | (____  
// _  | | |  __  ( \____ \   | |     | |   | |  ___  |\____ \   | |  |  ___) |  __  / \____ \ 
//| |_| | | |__)  )_____) )  | |_____| |___| | |   | |_____) )  | |  | |_____| |  \ \ _____) )
// \___/  |______/(______/    \______)\_____/|_|   |_(______/   |_|  |_______)_|   |_(______/ 
//
// PLAN ₿                                                                                     
//
// BTC: 19oUeJ9rkrJ1siGvnd4wahQVMGjDiFoAiN
//
// https://www.lookintobitcoin.com/